
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:mso="urn:schemas-microsoft-com:office:office" xmlns:msdt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Counterparty Credit Risk and CVA</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-04-22"><meta name="DC.source" content="script_CCR_pub.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
<!--[if gte mso 9]><xml>
<mso:CustomDocumentProperties>
<mso:_dlc_DocId msdt:dt="string">FV3TYEPWNNQC-18-29280</mso:_dlc_DocId>
<mso:_dlc_DocIdItemGuid msdt:dt="string">7df32a63-9f41-4bdd-8132-86af4351dae5</mso:_dlc_DocIdItemGuid>
<mso:_dlc_DocIdUrl msdt:dt="string">http://sharepoint/marketing/marcomm/seminars/emea_seminars/_layouts/DocIdRedir.aspx?ID=FV3TYEPWNNQC-18-29280, FV3TYEPWNNQC-18-29280</mso:_dlc_DocIdUrl>
</mso:CustomDocumentProperties>
</xml><![endif]-->
</head><body><div class="content"><h1>Counterparty Credit Risk and CVA</h1><!--introduction--><p>This example shows how to compute the unilateral Credit Value (Valuation) Adjustment (CVA) for a bank holding a portfolio of vanilla interest rate swaps with several counterparties.  CVA is the expected loss on an over-the-counter instrument or portfolio of instruments due to counterparty default.  The CVA for a particular counterparty is defined as the sum over all points in time of the discounted expected exposure at each moment multiplied by the probability that the counterparty defaults at that moment, all multiplied by 1 minus the recovery rate.  The Credit Value (Valuation) Adjustment (CVA) formula is:</p><p><img src="script_CCR_pub_eq69386.png" alt="$CVA = (1-R) \int_{0}^{T} discEE(t) dPD(t)$"></p><p>Where <tt>R</tt> is the recovery, <tt>discEE</tt> the discounted expected exposure at time t, and <tt>PD</tt> the default probability distribution.</p><p>The expected exposure is computed by first simulating many future scenarios of risk factors for the given instrument or portfolio.  Risk factors can be interest rates, FX rates, equity or commodity prices, or anything that will affect the market value of the instruments.  Once a sufficient set of scenarios has been simulated, the contract or portfolio can be priced on a series of future dates for each scenario.  The result is a matrix, or "cube", of instrument values.</p><p>These prices are converted into exposures after taking into account collateral agreements that the bank might have in place as well as netting agreements where the values of several instruments may offset each other, lowering their total exposure.</p><p>The instrument values for each scenario are discounted to compute the discounted exposures.  The discounted expected exposures can then be computed by a simple average of the discounted exposures at each simulation date.</p><p>Finally, counterparty default probabilities are typically derived from credit default swap market quotes and the CVA for the counterparty can be computed according to the above formula.</p><p>For this example we will work with a portfolio of vanilla interest rate swaps with the goal of computing the CVA for a particular counterparty.</p><p>This example can run slowly on some machines.  If you have the Parallel Computing Toolbox&#8482; installed it can improve the performance.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Import Data 1: Read Swap Portfolio</a></li><li><a href="#2">Import Data 2: Read Zero Curve</a></li><li><a href="#3">Setup Tunable Simulation Parameters</a></li><li><a href="#4">Compute Initial Prices for All Swaps</a></li><li><a href="#5">IR Simulation 1: Setup Hull-White Single Factor Model</a></li><li><a href="#6">IR Simulation 2: Simulate Scenarios</a></li><li><a href="#7">IR Simulation 3: Inspect a Few Scenarios</a></li><li><a href="#8">Price Portfolio 1: Compute Mark to Market Swap Prices</a></li><li><a href="#9">Price Portfolio 2: Inspect Scenario Prices</a></li><li><a href="#10">Price Portfolio 3: Visualize Simulated Portfolio Values</a></li><li><a href="#11">Exposure 1: Compute Exposure by Counterparty</a></li><li><a href="#12">Exposure 2: Exposure Profiles</a></li><li><a href="#13">Exposure 3: Discounted Exposures</a></li><li><a href="#14">Calibrating Probability of Default Curves</a></li><li><a href="#15">CVA Computation</a></li><li><a href="#16">References</a></li></ul></div><h2>Import Data 1: Read Swap Portfolio<a name="1"></a></h2><p>The portfolio of swaps is close to zero value at time t=0.  Each swap is associated with a counterparty and may or may not be included in a netting agreement.</p><pre class="codeinput"><span class="comment">% Read swaps from spreadsheet</span>
swapFile = <span class="string">'CCR Data.xlsx'</span>;
swaps = dataset(<span class="string">'XLSFile'</span>,swapFile,<span class="string">'Sheet'</span>,<span class="string">'Swaps'</span>);


swaps.Maturity     = datenum(swaps.Maturity, <span class="string">'dd/mm/yyyy'</span>);
swaps.LegType      = [swaps.LegType ~swaps.LegType];
swaps.LegRate      = [swaps.LegRateReceiving swaps.LegRatePaying];
swaps.LegReset     = ones(size(swaps.LegType));

numSwaps = numel(swaps.Counterparty);
numCounterparties = max(swaps.Counterparty);
</pre><h2>Import Data 2: Read Zero Curve<a name="2"></a></h2><p>Import zero curve data and set up IRDataCurve object to interpolate dates</p><pre class="codeinput">Settle = datenum(<span class="string">'14-Dec-2007'</span>);

ZeroData = dataset(<span class="string">'xlsfile'</span>, swapFile, <span class="string">'Sheet'</span>, <span class="string">'Zero'</span>, <span class="string">'Range'</span>, <span class="string">'A4:C12'</span>);
ZeroData.Date = datenum(ZeroData.Date, <span class="string">'dd/mm/yyyy'</span>);

Compounding = 2;
Basis = 0;

<span class="comment">% Set properties of interest-rate structure.</span>
RateSpec = intenvset(<span class="string">'StartDates'</span>, Settle,<span class="string">'EndDates'</span>, ZeroData.Date,<span class="keyword">...</span>
    <span class="string">'Rates'</span>, ZeroData.Rate,<span class="string">'Compounding'</span>,Compounding,<span class="string">'Basis'</span>,Basis);

<span class="comment">% Create an IRCurve object (Interest Rate).  We will use this for computing</span>
<span class="comment">% instantaneous forward rates during the calculation of the Hull-White short</span>
<span class="comment">% rate path.</span>
RateCurveObj = IRDataCurve(<span class="string">'Zero'</span>,Settle,ZeroData.Date,ZeroData.Rate,<span class="keyword">...</span>
                           <span class="string">'Compounding'</span>, Compounding,<span class="string">'Basis'</span>, Basis);

figure;
plot(ZeroData.Date, ZeroData.Rate, <span class="string">'o-'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'b'</span>, <span class="string">'LineWidth'</span>, 1.5);
xlabel(<span class="string">'Date'</span>); datetick;
ylabel(<span class="string">'Zero rate'</span>); grid <span class="string">on</span>;
title(<span class="string">'Zero Curve at Settle Date'</span>);
</pre><img vspace="5" hspace="5" src="script_CCR_pub_01.png" alt=""> <h2>Setup Tunable Simulation Parameters<a name="3"></a></h2><p>We can vary the number of simulated interest rate scenarios we generate by tuning the variable here.  We set our simulation dates to be more frequent at first, then turning less frequent further in the future.</p><pre class="codeinput"><span class="comment">% Number of Monte Carlo simulations</span>
numScenarios = 100;

<span class="comment">% Compute monthly simulation dates, then quarterly dates later.</span>
simulationDates = datemnth(Settle+1,1:12);
simulationDates = [simulationDates datemnth(simulationDates(end),3:3:74)];

stem(swaps.Maturity, swaps.LegType(:,1)*2-1, <span class="string">'Marker'</span>, <span class="string">'o'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'b'</span>);
hold <span class="string">on</span>; plot(simulationDates, zeros(size(simulationDates)), <span class="string">'r+'</span>);
datetick; legend(<span class="string">'Swap maturities'</span>, <span class="string">'Simulation dates'</span>);
ylim([-1.5 1.5]); grid <span class="string">on</span>; hold <span class="string">off</span>; set(gca,<span class="string">'YTick'</span>,[]); title(<span class="string">'Relevant Dates'</span>);
</pre><img vspace="5" hspace="5" src="script_CCR_pub_02.png" alt=""> <h2>Compute Initial Prices for All Swaps<a name="4"></a></h2><pre class="codeinput"><span class="comment">%Price swap instrument from set of zero curves</span>
currentPrices = swapbyzero(RateSpec,swaps.LegRate,Settle,swaps.Maturity,<span class="keyword">...</span>
    <span class="string">'Principal'</span>,swaps.Principal,<span class="string">'LegType'</span>,swaps.LegType,<span class="keyword">...</span>
    <span class="string">'LatestFloatingRate'</span>,swaps.LatestFloatingRate);

<span class="comment">% For each simulation date, compute last floating reset date per swap</span>
floatDates = cfdates(Settle-360,swaps.Maturity,swaps.Period);
swaps.LastFloatingDate = zeros(numSwaps,numel(simulationDates));
<span class="keyword">for</span> i = numel(simulationDates):-1:1
    thisDate = simulationDates(i);
    floatDates(floatDates &gt; thisDate) = 0;
    swaps.LastFloatingDate(:,i) = max(floatDates,[],2);
<span class="keyword">end</span>
</pre><h2>IR Simulation 1: Setup Hull-White Single Factor Model<a name="5"></a></h2><p>The risk factor we will simulate to value our instruments is the zero curve.  For this example we will model the interest rate term structure using the one-factor Hull-White model.  This is a model of the short rate and is defined as:</p><p><img src="script_CCR_pub_eq19819.png" alt="$$ dr = [ \theta(t) - ar ] dt+ \sigma dz $$"></p><p>where</p><div><ul><li><img src="script_CCR_pub_eq22585.png" alt="$dr$">: Change in the short rate after a small change in time, <img src="script_CCR_pub_eq17521.png" alt="$dt$"></li><li><img src="script_CCR_pub_eq34276.png" alt="$a$">:  Mean reversion rate</li><li><img src="script_CCR_pub_eq24873.png" alt="$\sigma$">:  Volatility of the short rate</li><li><img src="script_CCR_pub_eq99339.png" alt="$dz$">:  A Weiner process (a standard normal process)</li><li><img src="script_CCR_pub_eq60591.png" alt="$\theta(t)$">:  Drift function defined as:</li></ul></div><p><img src="script_CCR_pub_eq85950.png" alt="$$\theta(t) = F_t (0,t) + aF(0,t)+ \frac{\sigma^2}{2a}(1-e^{-2at})$$"></p><p><img src="script_CCR_pub_eq27253.png" alt="$F(0,t)$">:  Instantaneous forward rate at time <img src="script_CCR_pub_eq07064.png" alt="$t$"></p><p><img src="script_CCR_pub_eq27786.png" alt="$F_t (0,t)$">:  Partial derivative of <img src="script_CCR_pub_eq86924.png" alt="$F$"> with respect to time</p><p>Once we have simulated a path of the short rate we generate a full yield curve at each simulation date using the formula:</p><p><img src="script_CCR_pub_eq47650.png" alt="$$R(t,T) = -\frac{1}{(T-t)} \ln A(t,T) + \frac{1}{(T-t)} B(t,T)r(t)$$"></p><p><img src="script_CCR_pub_eq13197.png" alt="$$\ln A(t,T) = \ln \frac{P(0,T)}{P(0,t)} + B(t,T) F(0,t) - \frac{1}{4a^3} \sigma^2 (e^{-aT}-e^{-at} )^2 (e^{2at}-1)$$"></p><p><img src="script_CCR_pub_eq43282.png" alt="$$B(t,T)=  \frac{1-e^{-a(T-t)}}{a}$$"></p><p><img src="script_CCR_pub_eq50265.png" alt="$R(t,T)$">:  Zero rate at time <img src="script_CCR_pub_eq07064.png" alt="$t$"> for a period of <img src="script_CCR_pub_eq09112.png" alt="$T-t$"></p><p><img src="script_CCR_pub_eq75038.png" alt="$P(t,T)$">:  Price of a zero coupon bond at time <img src="script_CCR_pub_eq07064.png" alt="$t$"> that pays one dollar at time <img src="script_CCR_pub_eq57315.png" alt="$T$"></p><p>Each scenario contains the full term structure moving forward through time, modeled at each of our selected simulation dates.</p><p>Refer to "Calibrating the Hull-White Model Using Market Data" example in the Financial Instruments Toolbox&#8482; Users' Guide for more details on Hull-White one-factor model calibration.</p><pre class="codeinput">Alpha = 0.2;
Sigma = 0.015;

r0 = RateCurveObj.getZeroRates(Settle+1,<span class="string">'Compounding'</span>,-1);
t0 = Settle;

<span class="comment">% Construct SDE object</span>
FwdRates = RateCurveObj.getForwardRates(t0+1:max(swaps.Maturity),<span class="string">'Compounding'</span>,-1);
hullwhite1 = hwv(Alpha,@(t,x) hw1LevelFun(t0,t,FwdRates,Alpha,Sigma),<span class="keyword">...</span>
    Sigma,<span class="string">'StartState'</span>,r0)

<span class="comment">% Store all model calibration information</span>
calibration.RateCurveObj = RateCurveObj;
calibration.Tenor = ZeroData.Tenor;
calibration.ShortRateModel = hullwhite1;
calibration.Alpha = Alpha;
calibration.Sigma = Sigma;
</pre><pre class="codeoutput">hullwhite1 = 
   Class HWV: Hull-White/Vasicek
   ----------------------------------------
     Dimensions: State = 1, Brownian = 1
   ----------------------------------------
      StartTime: 0
     StartState: 0.0317681
    Correlation: 1
          Drift: drift rate function F(t,X(t)) 
      Diffusion: diffusion rate function G(t,X(t)) 
     Simulation: simulation method/function simByEuler
          Sigma: 0.015
          Level: function @(t,x)hw1LevelFun(t0,t,FwdRates,Alpha,Sigma)
          Speed: 0.2
</pre><h2>IR Simulation 2: Simulate Scenarios<a name="6"></a></h2><p>For each scenario, we simulate the future interest rate curve at each valuation date using the Hull-White one-factor interest rate model.</p><p>If the Parallel Computing Toolbox is installed then the scenario generation is done in parallel using the <tt>parfor</tt> loop.  This will improve performance as the scenarios are computed in parallel across all MATLAB workers.</p><pre class="codeinput"><span class="comment">% Pre-allocate scenarios data structure</span>
sampleScenario = hgenerateScenario(calibration,Settle,simulationDates);
scenarios = repmat(sampleScenario,numScenarios,1);

initialOneYearRate = RateCurveObj.getZeroRates(Settle + 365,<span class="string">'Compounding'</span>,-1);

<span class="comment">% Use reproducible random number generator (vary the seed to produce</span>
<span class="comment">% different random scenarios)</span>
stream = RandStream.create(<span class="string">'mrg32k3a'</span>,<span class="string">'NumStreams'</span>,numScenarios, <span class="string">'Seed'</span>,0);

<span class="comment">% Simulate all scenarios and compute instrument values in parallel.  If you</span>
<span class="comment">% have the Parallel Computing Toolbox, you should open a matlabpool before</span>
<span class="comment">% running this section.</span>

<span class="keyword">for</span> scenarioIdx = 1:numScenarios

    <span class="comment">% Save state of random number generator</span>
    defaultStreamLocal = RandStream.getGlobalStream();
    savedStateLocal = defaultStreamLocal.State;

    <span class="comment">% Setup new random number generator state for each scenario</span>
    RandStream.setGlobalStream(stream);
    set(stream,<span class="string">'Substream'</span>,scenarioIdx);

    <span class="comment">% Create a scenario</span>
    scenarios(scenarioIdx) = hgenerateScenario(calibration,Settle,simulationDates);

    <span class="comment">% Restore random number generator state</span>
    RandStream.setGlobalStream(defaultStreamLocal);
    defaultStreamLocal.State = savedStateLocal;

<span class="keyword">end</span>
</pre><h2>IR Simulation 3: Inspect a Few Scenarios<a name="7"></a></h2><p>Create a surface plot of the yield curve evolution for a particular scenario.</p><pre class="codeinput"><span class="keyword">for</span> i = 1:8
    clf;
    surf(scenarios(i).Dates, scenarios(i).Tenor, scenarios(i).Rates)
    axis <span class="string">tight</span>
    datetick(<span class="string">'x'</span>,<span class="string">'mmmyy'</span>);
    xlabel(<span class="string">'Observation Date'</span>);
    ylabel(<span class="string">'Tenor (Months)'</span>);
    zlabel(<span class="string">'Rates'</span>);
    set(gca,<span class="string">'View'</span>,[54.5 54]);
    title(sprintf(<span class="string">'Scenario %d Yield Curve Evolution\n'</span>,i));
    snapnow;
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="script_CCR_pub_03.png" alt=""> <img vspace="5" hspace="5" src="script_CCR_pub_04.png" alt=""> <img vspace="5" hspace="5" src="script_CCR_pub_05.png" alt=""> <img vspace="5" hspace="5" src="script_CCR_pub_06.png" alt=""> <img vspace="5" hspace="5" src="script_CCR_pub_07.png" alt=""> <img vspace="5" hspace="5" src="script_CCR_pub_08.png" alt=""> <img vspace="5" hspace="5" src="script_CCR_pub_09.png" alt=""> <img vspace="5" hspace="5" src="script_CCR_pub_10.png" alt=""> <h2>Price Portfolio 1: Compute Mark to Market Swap Prices<a name="8"></a></h2><p>For each scenario the swap portfolio is priced at each future simulation date.  Prices are computed using a price approximation function, <tt>hswapapprox</tt>.  It is common in CVA applications to use simplified approximation functions when pricing instruments due to the performance requirements of these Monte Carlo simulations.</p><p>Since the simulation dates do not correspond to the swaps cash flow dates (where the floating rates are reset) we estimate the latest floating rate with the 1-year rate (all swaps have period 1 year) interpolated between the nearest simulated rate curves.</p><p>The swap prices are then aggregated into a "cube" of values which contains all future instrument values at each simulation date for each scenario.  The resulting cube of instrument prices is a 3 dimensional matrix where each row represents an instrument, each column a simulation date, and each "page" a different simulated scenario.</p><pre class="codeinput"><span class="comment">% Allocate cube of simulated values: rows correspond to instruments,</span>
<span class="comment">% columns to valuation dates, "pages" to scenarios</span>
simulatedValues = zeros(numSwaps,numel(simulationDates),numScenarios);

<span class="keyword">parfor</span> i = 1:numScenarios

    <span class="comment">% Compute all mark-to-market values for this scenario.  We use an</span>
    <span class="comment">% approximation function here to improve performance.</span>
    scenarioValues = hcomputeMTMValues(swaps,simulationDates,<span class="keyword">...</span>
        scenarios(i),Settle,initialOneYearRate);

    <span class="comment">% Store results</span>
    simulatedValues(:,:,i) = scenarioValues;

<span class="keyword">end</span>
</pre><h2>Price Portfolio 2: Inspect Scenario Prices<a name="9"></a></h2><p>Create a plot of swap price evolution for a particular scenario.</p><pre class="codeinput">i = 15;
clf
pos = get(gcf,<span class="string">'Position'</span>);
set(gcf,<span class="string">'Position'</span>,[pos(1:2) 900 400]);
subplot(1,2,1);
surf(scenarios(i).Dates, scenarios(i).Tenor, scenarios(i).Rates)
axis <span class="string">tight</span>
datetick(<span class="string">'x'</span>,<span class="string">'mmmyy'</span>);
xlabel(<span class="string">'Observation Date'</span>);
ylabel(<span class="string">'Tenor (Months)'</span>);
zlabel(<span class="string">'Rates'</span>);
set(gca,<span class="string">'View'</span>,[54.5 54]);
title(sprintf(<span class="string">'Scenario %d Yield Curve Evolution\n'</span>,i));
subplot(1,2,2);
plot(scenarios(i).Dates, simulatedValues(:,:,i));
datetick;
ylabel(<span class="string">'Mark-To-Market Price'</span>);
title(sprintf(<span class="string">'Swap prices along scenario %d'</span>, i));
</pre><img vspace="5" hspace="5" src="script_CCR_pub_11.png" alt=""> <h2>Price Portfolio 3: Visualize Simulated Portfolio Values<a name="10"></a></h2><p>We plot the total portfolio value for each scenario of our simulation. As each scenario moves forward in time the values of the instruments will move up or down depending on how the modeled interest rate term structure changes.  As the swaps get closer to maturity, their values will begin to approach zero since the aggregate value of all remaining cash flows will decrease after each cash flow date.</p><pre class="codeinput"><span class="comment">% Append initial prices/date to our simulation data</span>
values = cat(2,repmat(currentPrices,[1 1 numScenarios]),simulatedValues);
dates = [Settle simulationDates];

<span class="comment">% View portfolio value over time</span>
figure;
totalPortValues = squeeze(sum(values, 1));
plot(dates,totalPortValues);
title(<span class="string">'Total MTM Portfolio Value for All Scenarios'</span>);
datetick(<span class="string">'x'</span>,<span class="string">'mmmyy'</span>)
ylabel(<span class="string">'Portfolio Value ($)'</span>)
xlabel(<span class="string">'Simulation Dates'</span>)
</pre><img vspace="5" hspace="5" src="script_CCR_pub_12.png" alt=""> <h2>Exposure 1: Compute Exposure by Counterparty<a name="11"></a></h2><p>The exposure of a particular contract (i) at time t is the maximum of the contract value (Vi) and 0:</p><p><img src="script_CCR_pub_eq17288.png" alt="$$ E_i (t) = \max \{ V_i (t),0 \} $$"></p><p>And the exposure for a particular counterparty is simply a sum of the individual contract exposures:</p><p><img src="script_CCR_pub_eq32703.png" alt="$$ E(t)= \sum E_i (t) = \sum \max \{ V_i (t),0 \} $$"></p><p>In the presence of netting agreements, however, contracts are aggregated together and can offset each other.  Therefore the total exposure of all instruments in a netting agreement is</p><p><img src="script_CCR_pub_eq26399.png" alt="$$ E(t) = \max \{ \sum V_i (t), 0 \} $$"></p><p>We compute these exposures for each counterparty at each simulation date.</p><pre class="codeinput"><span class="comment">% Additive exposure is computed at the netting set level.  Exposure of an</span>
<span class="comment">% unnetted instrument is equal to the market value of the instrument if the</span>
<span class="comment">% instrument has positive value, otherwise it is zero.</span>
instrument_exposures = zeros(size(values));
unnettedIdx = swaps.NettingID == 0;
instrument_exposures(unnettedIdx,:,:) = max(values(unnettedIdx,:,:),0);

<span class="comment">% Instruments included in a netting agreement have exposure equal to their</span>
<span class="comment">% value when the netting agreement has positive aggregate value, otherwise</span>
<span class="comment">% their exposure is zero.  We compute this per netting agreement, but in</span>
<span class="comment">% this case each counterparty has only a single netting agreement.</span>
<span class="keyword">for</span> j = 1:numCounterparties

    nettedIdx = swaps.NettingID == j;

    <span class="comment">% Exposures for instruments under netting agreements</span>
    nettedValues = values(nettedIdx,:,:);
    nettedExposure = max(sum(nettedValues,1),0);
    positiveIdx = nettedExposure &gt; 0;
    instrument_exposures(nettedIdx,positiveIdx) = values(nettedIdx,positiveIdx);

<span class="keyword">end</span>

<span class="comment">% Sum the instrument exposures for each counterparty</span>
exposures = zeros(numCounterparties,numel(dates),numScenarios);
<span class="keyword">for</span> j = 1:numCounterparties

    cpSwapIdx = swaps.Counterparty == j;
    exposures(j,:,:) = squeeze(sum(instrument_exposures(cpSwapIdx,:,:),1));

<span class="keyword">end</span>
</pre><h2>Exposure 2: Exposure Profiles<a name="12"></a></h2><p>Several exposure profiles are useful when analyzing the potential future exposure of a bank to a counterparty. Here we compute several (non-discounted) exposure profiles per counterparty as well as for the entire portfolio.</p><div><ul><li><tt>PE</tt> : Peak Exposure : A high percentile (95%) of the distribution of exposures at any particular future date.  Also called Potential Future Exposure (PFE).</li><li><tt>MPE</tt> : Maximum Peak Exposure : The maximum peak exposure across all dates</li><li><tt>EE</tt> : Expected Exposure : The mean (average) of the distribution of exposures at each date</li><li><tt>EPE</tt> : Expected Positive Exposure : Weighted average over time of the expected exposure</li><li><tt>EffEE</tt> : Effective Expected Exposure : The maximum expected exposure at any time, t, or previous time</li><li><tt>EffEPE</tt> : Effective Expected Positive Exposure : The weighted average of the effective expected exposure</li></ul></div><p>For further definitions, see for example Basel II document in references.</p><p>Here we use a function <i>plotCPExposure</i> to plot certain exposure profiles over the exposures computed for every scenario, for each counterparty.</p><pre class="codeinput"><span class="keyword">for</span> i = 1:size(exposures,1)
	clf
    plotCPExposure(dates,squeeze(exposures(i,:,:)),i);
	snapnow;
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="script_CCR_pub_13.png" alt=""> <img vspace="5" hspace="5" src="script_CCR_pub_14.png" alt=""> <img vspace="5" hspace="5" src="script_CCR_pub_15.png" alt=""> <img vspace="5" hspace="5" src="script_CCR_pub_16.png" alt=""> <img vspace="5" hspace="5" src="script_CCR_pub_17.png" alt=""> <h2>Exposure 3: Discounted Exposures<a name="13"></a></h2><p>We compute the discounted expected exposures using the discount factors from each simulated interest rate scenario.  The discount factor for a given valuation date in a given scenario is the product of the incremental discount factors from one simulation date to the next, along the interest rate path of that scenario.</p><pre class="codeinput"><span class="comment">% Get discounted exposures per counterparty, for each scenario</span>
discExp = zeros(size(exposures));
<span class="keyword">for</span> i=1:numScenarios
    discExp(:,:,i) = bsxfun(@times,scenarios(i).Disc,exposures(:,:,i));
<span class="keyword">end</span>

<span class="comment">% Discounted expected exposure</span>
discEE = mean(discExp,3);

<span class="comment">% Plot counterparty discounted EE</span>
clf
plot(dates,discEE)
datetick(<span class="string">'x'</span>,<span class="string">'mmmyy'</span>); grid <span class="string">on</span>;
title(<span class="string">'Discounted Expected Exposure for Each Counterparty'</span>);
ylabel(<span class="string">'Discounted Exposure ($)'</span>)
xlabel(<span class="string">'Simulation Dates'</span>)
</pre><img vspace="5" hspace="5" src="script_CCR_pub_18.png" alt=""> <h2>Calibrating Probability of Default Curves<a name="14"></a></h2><p>The default probability for a given counterparty is implied by the current market spreads of the counterparty's credit default swaps.  We use the function <tt>cdsbootstrap</tt> to generate the cumulative probability of default at each simulation date.</p><pre class="codeinput"><span class="comment">% Import CDS Market Information for each counterparty</span>
CDS = dataset(<span class="string">'xlsfile'</span>, <span class="string">'CCR Data.xlsx'</span>, <span class="string">'Sheet'</span>, <span class="string">'CDS'</span>, <span class="string">'Range'</span>, <span class="string">'A3:F8'</span>)
CDS.Date = datenum(CDS.Date, <span class="string">'dd/mm/yyyy'</span>);
CDS.Spreads = double(CDS(:,2:end));

DefProb = zeros(length(dates), size(CDS.Spreads,2));
<span class="keyword">for</span> i = 1:size(DefProb,2)
    probData = cdsbootstrap([ZeroData.Date, ZeroData.Rate], [CDS.Date CDS.Spreads(:,i)],<span class="keyword">...</span>
                            Settle, <span class="string">'probDates'</span>, dates');
    DefProb(:,i) = probData(:,2);
<span class="keyword">end</span>

<span class="comment">% We plot of the cumulative probability of default for the counterparty in</span>
<span class="comment">% question.</span>

figure
plot(dates,DefProb)
title(<span class="string">'Default Probability Curve for Each Counterparty'</span>);
xlabel(<span class="string">'Date'</span>); grid <span class="string">on</span>;
ylabel(<span class="string">'Cumulative Probability'</span>)
datetick(<span class="string">'x'</span>,<span class="string">'mmmyy'</span>)
ylabel(<span class="string">'Probability of Default'</span>)
xlabel(<span class="string">'Simulation Dates'</span>)
</pre><pre class="codeoutput">Warning: Variable names were modified to make them valid MATLAB identifiers. 
CDS = 
    Date                CP1    CP2    CP3    CP4    CP5
    '20/03/2008'        140     85    115    170    140
    '20/03/2009'        175    120    150    205    185
    '20/03/2010'        210    170    195    245    215
    '20/03/2011'        265    215    240    285    275
    '20/03/2012'        310    255    290    320    340
</pre><img vspace="5" hspace="5" src="script_CCR_pub_19.png" alt=""> <h2>CVA Computation<a name="15"></a></h2><p>The Credit Value (Valuation) Adjustment (CVA) formula is:</p><p><img src="script_CCR_pub_eq69386.png" alt="$CVA = (1-R) \int_{0}^{T} discEE(t) dPD(t)$"></p><p>Where <tt>R</tt> is the recovery, <tt>discEE</tt> the discounted expected exposure at time t, and <tt>PD</tt> the default probability distribution. This assumes the exposure is independent of default (no wrong-way risk), and it also assumes the exposure were obtained using risk-neutral probabilities.</p><p>Here we approximate the integral with a finite sum over the valuation dates as:</p><p><img src="script_CCR_pub_eq18414.png" alt="$CVA (approx) = (1-R) \sum_{i=2}^n  discEE(t_i) (PD(t_i)-PD(t_{i-1}))$"></p><p>where t_1 is todays date, t_2,...,t_n the future valuation dates.</p><p>We assume CDS info corresponds to counterparty with index cpIdx.  The computed CVA is the present market value of our credit exposure to counterparty cpIdx.  For this example we set the recovery rate at 40%.</p><pre class="codeinput">Recovery = 0.4;
CVA = (1-Recovery) * sum(discEE(:,2:end)'.*diff(DefProb));

<span class="keyword">for</span> i = 1:length(CVA)
    fprintf(<span class="string">'CVA for counterparty %d = $%.2f\n'</span>,i,CVA(i));
<span class="keyword">end</span>

clf
bar(CVA); title(<span class="string">'CVA for each counterparty'</span>);
xlabel(<span class="string">'Counterparty'</span>); ylabel(<span class="string">'CVA $'</span>); grid <span class="string">on</span>;
</pre><pre class="codeoutput">CVA for counterparty 1 = $2241.21
CVA for counterparty 2 = $2885.59
CVA for counterparty 3 = $982.32
CVA for counterparty 4 = $6441.87
CVA for counterparty 5 = $7424.71
</pre><img vspace="5" hspace="5" src="script_CCR_pub_20.png" alt=""> <h2>References<a name="16"></a></h2><div><ol><li>Pykhtin, Michael, and Steven Zhu, <i>A Guide to Modelling Counterparty Credit Risk</i>, GARP, July/August 2007, issue 37, pp. 16-22. Available at: <a href="http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1032522">http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1032522</a>.</li><li>Basel II: <a href="http://www.bis.org/publ/bcbs128.pdf">http://www.bis.org/publ/bcbs128.pdf</a> page 256</li></ol></div><p class="footer">Copyright 2012 The MathWorks, Inc.<br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Counterparty Credit Risk and CVA
%
% This example shows how to compute the unilateral Credit Value (Valuation)
% Adjustment (CVA) for a bank holding a portfolio of vanilla interest rate
% swaps with several counterparties.  CVA is the expected loss on an
% over-the-counter instrument or portfolio of instruments due to
% counterparty default.  The CVA for a particular counterparty is defined
% as the sum over all points in time of the discounted expected exposure at
% each moment multiplied by the probability that the counterparty defaults
% at that moment, all multiplied by 1 minus the recovery rate.  The Credit
% Value (Valuation) Adjustment (CVA) formula is:
%
% $CVA = (1-R) \int_{0}^{T} discEE(t) dPD(t)$
%
% Where |R| is the recovery, |discEE| the discounted expected exposure at
% time t, and |PD| the default probability distribution.
%
% The expected exposure is computed by first simulating many future
% scenarios of risk factors for the given instrument or portfolio.  Risk
% factors can be interest rates, FX rates, equity or commodity prices, or
% anything that will affect the market value of the instruments.  Once a
% sufficient set of scenarios has been simulated, the contract or portfolio
% can be priced on a series of future dates for each scenario.  The result
% is a matrix, or "cube", of instrument values.
%
% These prices are converted into exposures after taking into account
% collateral agreements that the bank might have in place as well as
% netting agreements where the values of several instruments may offset
% each other, lowering their total exposure.
%
% The instrument values for each scenario are discounted to compute the
% discounted exposures.  The discounted expected exposures can then be
% computed by a simple average of the discounted exposures at each
% simulation date.
%
% Finally, counterparty default probabilities are typically derived from
% credit default swap market quotes and the CVA for the counterparty can be
% computed according to the above formula.
%
% For this example we will work with a portfolio of vanilla interest rate
% swaps with the goal of computing the CVA for a particular counterparty.
%
% This example can run slowly on some machines.  If you have the Parallel
% Computing Toolbox(TM) installed it can improve the performance.

%   Copyright 2012 The MathWorks, Inc.

%% Import Data 1: Read Swap Portfolio
% The portfolio of swaps is close to zero value at time t=0.  Each swap is
% associated with a counterparty and may or may not be included in a
% netting agreement.

% Read swaps from spreadsheet
swapFile = 'CCR Data.xlsx';
swaps = dataset('XLSFile',swapFile,'Sheet','Swaps');


swaps.Maturity     = datenum(swaps.Maturity, 'dd/mm/yyyy');
swaps.LegType      = [swaps.LegType ~swaps.LegType];
swaps.LegRate      = [swaps.LegRateReceiving swaps.LegRatePaying];
swaps.LegReset     = ones(size(swaps.LegType));

numSwaps = numel(swaps.Counterparty);
numCounterparties = max(swaps.Counterparty);

%% Import Data 2: Read Zero Curve
% Import zero curve data and set up IRDataCurve object to interpolate dates

Settle = datenum('14-Dec-2007');

ZeroData = dataset('xlsfile', swapFile, 'Sheet', 'Zero', 'Range', 'A4:C12');
ZeroData.Date = datenum(ZeroData.Date, 'dd/mm/yyyy');

Compounding = 2;
Basis = 0;

% Set properties of interest-rate structure.
RateSpec = intenvset('StartDates', Settle,'EndDates', ZeroData.Date,...
    'Rates', ZeroData.Rate,'Compounding',Compounding,'Basis',Basis);

% Create an IRCurve object (Interest Rate).  We will use this for computing 
% instantaneous forward rates during the calculation of the Hull-White short 
% rate path.
RateCurveObj = IRDataCurve('Zero',Settle,ZeroData.Date,ZeroData.Rate,...
                           'Compounding', Compounding,'Basis', Basis);

figure;
plot(ZeroData.Date, ZeroData.Rate, 'o-', 'MarkerFaceColor', 'b', 'LineWidth', 1.5);
xlabel('Date'); datetick;
ylabel('Zero rate'); grid on;
title('Zero Curve at Settle Date');

%% Setup Tunable Simulation Parameters
% We can vary the number of simulated interest rate scenarios we generate
% by tuning the variable here.  We set our simulation dates to be more
% frequent at first, then turning less frequent further in the future.

% Number of Monte Carlo simulations
numScenarios = 100;

% Compute monthly simulation dates, then quarterly dates later.
simulationDates = datemnth(Settle+1,1:12);
simulationDates = [simulationDates datemnth(simulationDates(end),3:3:74)];

stem(swaps.Maturity, swaps.LegType(:,1)*2-1, 'Marker', 'o', 'MarkerFaceColor', 'b'); 
hold on; plot(simulationDates, zeros(size(simulationDates)), 'r+');
datetick; legend('Swap maturities', 'Simulation dates');
ylim([-1.5 1.5]); grid on; hold off; set(gca,'YTick',[]); title('Relevant Dates');

%% Compute Initial Prices for All Swaps

%Price swap instrument from set of zero curves
currentPrices = swapbyzero(RateSpec,swaps.LegRate,Settle,swaps.Maturity,...
    'Principal',swaps.Principal,'LegType',swaps.LegType,...
    'LatestFloatingRate',swaps.LatestFloatingRate);

% For each simulation date, compute last floating reset date per swap
floatDates = cfdates(Settle-360,swaps.Maturity,swaps.Period);
swaps.LastFloatingDate = zeros(numSwaps,numel(simulationDates));
for i = numel(simulationDates):-1:1
    thisDate = simulationDates(i);
    floatDates(floatDates > thisDate) = 0;
    swaps.LastFloatingDate(:,i) = max(floatDates,[],2);
end


%% IR Simulation 1: Setup Hull-White Single Factor Model
% The risk factor we will simulate to value our instruments is the zero
% curve.  For this example we will model the interest rate term structure
% using the one-factor Hull-White model.  This is a model of the short
% rate and is defined as:
%
% $$ dr = [ \theta(t) - ar ] dt+ \sigma dz $$
%
% where
%
% * $dr$: Change in the short rate after a small change in time, $dt$
% * $a$:  Mean reversion rate
% * $\sigma$:  Volatility of the short rate
% * $dz$:  A Weiner process (a standard normal process)
% * $\theta(t)$:  Drift function defined as:
%
% $$\theta(t) = F_t (0,t) + aF(0,t)+ \frac{\sigma^2}{2a}(1-e^{-2at})$$
%
% $F(0,t)$:  Instantaneous forward rate at time $t$
%
% $F_t (0,t)$:  Partial derivative of $F$ with respect to time
%
% Once we have simulated a path of the short rate we generate a full yield
% curve at each simulation date using the formula:
%
% $$R(t,T) = -\frac{1}{(T-t)} \ln A(t,T) + \frac{1}{(T-t)} B(t,T)r(t)$$
%
% $$\ln A(t,T) = \ln \frac{P(0,T)}{P(0,t)} + B(t,T) F(0,t) - \frac{1}{4a^3} \sigma^2 (e^{-aT}-e^{-at} )^2 (e^{2at}-1)$$
%
% $$B(t,T)=  \frac{1-e^{-a(T-t)}}{a}$$
%
% $R(t,T)$:  Zero rate at time $t$ for a period of $T-t$
%
% $P(t,T)$:  Price of a zero coupon bond at time $t$ that pays one dollar at time $T$
%
% Each scenario contains the full term structure moving forward through
% time, modeled at each of our selected simulation dates.
%
% Refer to "Calibrating the Hull-White Model Using Market Data" example in
% the Financial Instruments Toolbox(TM) Users' Guide for more details on
% Hull-White one-factor model calibration.

Alpha = 0.2;
Sigma = 0.015;

r0 = RateCurveObj.getZeroRates(Settle+1,'Compounding',-1);
t0 = Settle;

% Construct SDE object
FwdRates = RateCurveObj.getForwardRates(t0+1:max(swaps.Maturity),'Compounding',-1);
hullwhite1 = hwv(Alpha,@(t,x) hw1LevelFun(t0,t,FwdRates,Alpha,Sigma),...
    Sigma,'StartState',r0)

% Store all model calibration information
calibration.RateCurveObj = RateCurveObj;
calibration.Tenor = ZeroData.Tenor;
calibration.ShortRateModel = hullwhite1;
calibration.Alpha = Alpha;
calibration.Sigma = Sigma;


%% IR Simulation 2: Simulate Scenarios
% For each scenario, we simulate the future interest rate curve at each
% valuation date using the Hull-White one-factor interest rate model.
%
% If the Parallel Computing Toolbox is installed then the scenario
% generation is done in parallel using the |parfor| loop.  This will
% improve performance as the scenarios are computed in parallel across all
% MATLAB workers.

% Pre-allocate scenarios data structure
sampleScenario = hgenerateScenario(calibration,Settle,simulationDates);
scenarios = repmat(sampleScenario,numScenarios,1);

initialOneYearRate = RateCurveObj.getZeroRates(Settle + 365,'Compounding',-1);

% Use reproducible random number generator (vary the seed to produce
% different random scenarios)
stream = RandStream.create('mrg32k3a','NumStreams',numScenarios, 'Seed',0);

% Simulate all scenarios and compute instrument values in parallel.  If you
% have the Parallel Computing Toolbox, you should open a matlabpool before
% running this section.

for scenarioIdx = 1:numScenarios
    
    % Save state of random number generator
    defaultStreamLocal = RandStream.getGlobalStream();
    savedStateLocal = defaultStreamLocal.State;
    
    % Setup new random number generator state for each scenario
    RandStream.setGlobalStream(stream);
    set(stream,'Substream',scenarioIdx);
   
    % Create a scenario
    scenarios(scenarioIdx) = hgenerateScenario(calibration,Settle,simulationDates);
    
    % Restore random number generator state
    RandStream.setGlobalStream(defaultStreamLocal);
    defaultStreamLocal.State = savedStateLocal;
    
end


%% IR Simulation 3: Inspect a Few Scenarios
% Create a surface plot of the yield curve evolution for a particular
% scenario.
for i = 1:8
    clf;
    surf(scenarios(i).Dates, scenarios(i).Tenor, scenarios(i).Rates)
    axis tight
    datetick('x','mmmyy');
    xlabel('Observation Date');
    ylabel('Tenor (Months)');
    zlabel('Rates');
    set(gca,'View',[54.5 54]);
    title(sprintf('Scenario %d Yield Curve Evolution\n',i));
    snapnow;
end


%% Price Portfolio 1: Compute Mark to Market Swap Prices
% For each scenario the swap portfolio is priced at each future simulation
% date.  Prices are computed using a price approximation function,
% |hswapapprox|.  It is common in CVA applications to use simplified
% approximation functions when pricing instruments due to the performance
% requirements of these Monte Carlo simulations.
%
% Since the simulation dates do not correspond to the swaps cash flow dates
% (where the floating rates are reset) we estimate the latest floating rate
% with the 1-year rate (all swaps have period 1 year) interpolated between
% the nearest simulated rate curves.
%
% The swap prices are then aggregated into a "cube" of values which
% contains all future instrument values at each simulation date for each
% scenario.  The resulting cube of instrument prices is a 3 dimensional
% matrix where each row represents an instrument, each column a simulation
% date, and each "page" a different simulated scenario.

% Allocate cube of simulated values: rows correspond to instruments,
% columns to valuation dates, "pages" to scenarios
simulatedValues = zeros(numSwaps,numel(simulationDates),numScenarios);

parfor i = 1:numScenarios

    % Compute all mark-to-market values for this scenario.  We use an
    % approximation function here to improve performance.
    scenarioValues = hcomputeMTMValues(swaps,simulationDates,...
        scenarios(i),Settle,initialOneYearRate);
    
    % Store results
    simulatedValues(:,:,i) = scenarioValues;
    
end



%% Price Portfolio 2: Inspect Scenario Prices
% Create a plot of swap price evolution for a particular scenario.
i = 15;
clf
pos = get(gcf,'Position');
set(gcf,'Position',[pos(1:2) 900 400]);
subplot(1,2,1);
surf(scenarios(i).Dates, scenarios(i).Tenor, scenarios(i).Rates)
axis tight
datetick('x','mmmyy'); 
xlabel('Observation Date');
ylabel('Tenor (Months)');
zlabel('Rates');
set(gca,'View',[54.5 54]);
title(sprintf('Scenario %d Yield Curve Evolution\n',i));
subplot(1,2,2);
plot(scenarios(i).Dates, simulatedValues(:,:,i));
datetick;
ylabel('Mark-To-Market Price');
title(sprintf('Swap prices along scenario %d', i));


%% Price Portfolio 3: Visualize Simulated Portfolio Values
% We plot the total portfolio value for each scenario of our simulation. As
% each scenario moves forward in time the values of the instruments will
% move up or down depending on how the modeled interest rate term structure
% changes.  As the swaps get closer to maturity, their values will begin to
% approach zero since the aggregate value of all remaining cash flows will
% decrease after each cash flow date.

% Append initial prices/date to our simulation data
values = cat(2,repmat(currentPrices,[1 1 numScenarios]),simulatedValues);
dates = [Settle simulationDates];

% View portfolio value over time
figure;
totalPortValues = squeeze(sum(values, 1));
plot(dates,totalPortValues);
title('Total MTM Portfolio Value for All Scenarios');
datetick('x','mmmyy')
ylabel('Portfolio Value ($)')
xlabel('Simulation Dates')


%% Exposure 1: Compute Exposure by Counterparty
% The exposure of a particular contract (i) at time t is the maximum of the
% contract value (Vi) and 0:
%
% $$ E_i (t) = \max \{ V_i (t),0 \} $$
%
% And the exposure for a particular counterparty is simply a sum of the
% individual contract exposures:
%
% $$ E(t)= \sum E_i (t) = \sum \max \{ V_i (t),0 \} $$
%
% In the presence of netting agreements, however, contracts are aggregated
% together and can offset each other.  Therefore the total exposure of all
% instruments in a netting agreement is  
%
% $$ E(t) = \max \{ \sum V_i (t), 0 \} $$
%
% We compute these exposures for each counterparty at each simulation date.

% Additive exposure is computed at the netting set level.  Exposure of an
% unnetted instrument is equal to the market value of the instrument if the
% instrument has positive value, otherwise it is zero.
instrument_exposures = zeros(size(values));
unnettedIdx = swaps.NettingID == 0;
instrument_exposures(unnettedIdx,:,:) = max(values(unnettedIdx,:,:),0);

% Instruments included in a netting agreement have exposure equal to their
% value when the netting agreement has positive aggregate value, otherwise
% their exposure is zero.  We compute this per netting agreement, but in
% this case each counterparty has only a single netting agreement.
for j = 1:numCounterparties

    nettedIdx = swaps.NettingID == j;
    
    % Exposures for instruments under netting agreements
    nettedValues = values(nettedIdx,:,:);
    nettedExposure = max(sum(nettedValues,1),0);
    positiveIdx = nettedExposure > 0;
    instrument_exposures(nettedIdx,positiveIdx) = values(nettedIdx,positiveIdx);
    
end

% Sum the instrument exposures for each counterparty
exposures = zeros(numCounterparties,numel(dates),numScenarios);
for j = 1:numCounterparties

    cpSwapIdx = swaps.Counterparty == j;
    exposures(j,:,:) = squeeze(sum(instrument_exposures(cpSwapIdx,:,:),1));
    
end


%% Exposure 2: Exposure Profiles
% Several exposure profiles are useful when analyzing the potential future
% exposure of a bank to a counterparty. Here we compute several
% (non-discounted) exposure profiles per counterparty as well as for the
% entire portfolio.
%
% * |PE| : Peak Exposure : A high percentile (95%) of the distribution of
% exposures at any particular future date.  Also called Potential Future
% Exposure (PFE).
% * |MPE| : Maximum Peak Exposure : The maximum peak exposure across all
% dates
% * |EE| : Expected Exposure : The mean (average) of the distribution of
% exposures at each date
% * |EPE| : Expected Positive Exposure : Weighted average over time of the
% expected exposure
% * |EffEE| : Effective Expected Exposure : The maximum expected exposure at
% any time, t, or previous time  
% * |EffEPE| : Effective Expected Positive Exposure : The weighted average
% of the effective expected exposure
%
% For further definitions, see for example Basel II document in references.
%
% Here we use a function _plotCPExposure_ to plot certain exposure
% profiles over the exposures computed for every scenario, for each
% counterparty. 

for i = 1:size(exposures,1)
	clf
    plotCPExposure(dates,squeeze(exposures(i,:,:)),i);
	snapnow;
end


%% Exposure 3: Discounted Exposures
% We compute the discounted expected exposures using the discount factors
% from each simulated interest rate scenario.  The discount factor for a
% given valuation date in a given scenario is the product of the
% incremental discount factors from one simulation date to the next, along
% the interest rate path of that scenario.

% Get discounted exposures per counterparty, for each scenario
discExp = zeros(size(exposures));
for i=1:numScenarios
    discExp(:,:,i) = bsxfun(@times,scenarios(i).Disc,exposures(:,:,i));
end

% Discounted expected exposure
discEE = mean(discExp,3);

% Plot counterparty discounted EE
clf
plot(dates,discEE)
datetick('x','mmmyy'); grid on;
title('Discounted Expected Exposure for Each Counterparty');
ylabel('Discounted Exposure ($)')
xlabel('Simulation Dates')


%% Calibrating Probability of Default Curves
% The default probability for a given counterparty is implied by the
% current market spreads of the counterparty's credit default swaps.  We
% use the function |cdsbootstrap| to generate the cumulative probability of
% default at each simulation date.

% Import CDS Market Information for each counterparty
CDS = dataset('xlsfile', 'CCR Data.xlsx', 'Sheet', 'CDS', 'Range', 'A3:F8')
CDS.Date = datenum(CDS.Date, 'dd/mm/yyyy');
CDS.Spreads = double(CDS(:,2:end));

DefProb = zeros(length(dates), size(CDS.Spreads,2));
for i = 1:size(DefProb,2)
    probData = cdsbootstrap([ZeroData.Date, ZeroData.Rate], [CDS.Date CDS.Spreads(:,i)],...
                            Settle, 'probDates', dates');
    DefProb(:,i) = probData(:,2);
end

% We plot of the cumulative probability of default for the counterparty in
% question.

figure
plot(dates,DefProb)
title('Default Probability Curve for Each Counterparty');
xlabel('Date'); grid on;
ylabel('Cumulative Probability')
datetick('x','mmmyy')
ylabel('Probability of Default')
xlabel('Simulation Dates')


%% CVA Computation
%
% The Credit Value (Valuation) Adjustment (CVA) formula is:
%
% $CVA = (1-R) \int_{0}^{T} discEE(t) dPD(t)$
%
% Where |R| is the recovery, |discEE| the discounted expected exposure at
% time t, and |PD| the default probability distribution. This assumes the
% exposure is independent of default (no wrong-way risk), and it also
% assumes the exposure were obtained using risk-neutral probabilities.
%
% Here we approximate the integral with a finite sum over the valuation
% dates as:
%
% $CVA (approx) = (1-R) \sum_{i=2}^n  discEE(t_i) (PD(t_i)-PD(t_{i-1}))$
%
% where t_1 is todays date, t_2,...,t_n the future valuation dates.
%
% We assume CDS info corresponds to counterparty with index cpIdx.  The
% computed CVA is the present market value of our credit exposure to
% counterparty cpIdx.  For this example we set the recovery rate at 40%.

Recovery = 0.4;
CVA = (1-Recovery) * sum(discEE(:,2:end)'.*diff(DefProb));

for i = 1:length(CVA)
    fprintf('CVA for counterparty %d = $%.2f\n',i,CVA(i));
end

clf
bar(CVA); title('CVA for each counterparty');
xlabel('Counterparty'); ylabel('CVA $'); grid on;

%% References
%
% # Pykhtin, Michael, and Steven Zhu, _A Guide to Modelling Counterparty
% Credit Risk_, GARP, July/August 2007, issue 37, pp. 16-22. Available at:
% http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1032522.
% # Basel II: http://www.bis.org/publ/bcbs128.pdf page 256




##### SOURCE END #####
--></body></html>